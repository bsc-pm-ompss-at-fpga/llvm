// RUN: %clang_cc1 -fompss-2 -fompss-fpga-hls-tasks-dir %{fs-tmp-root} -fompss-fpga -fompss-fpga-wrapper-code -fompss-fpga-dump -ferror-limit 100 %s | FileCheck %s
// expected-no-diagnostics

#include "Inputs/header.h"
#include "Inputs/header.fpga.h"
const int VAL = 0;
void depend(int *ptr);
#pragma oss task device(fpga)
void foo(int *ptr) {
    depend(ptr);
}
void depend(int *ptr) {
    int exprExample = OMPIF_Comm_rank() * OMPIF_Comm_size();
    OMPIF_Send(ptr, exprExample); // Preserves paramaters
    nanos6_fpga_memcpy_wideport_in(ptr);
}
// CHECK:foo
// CHECK-NEXT:///////////////////
// CHECK-NEXT:// Automatic IP Generated by OmpSs@FPGA compiler
// CHECK-NEXT:///////////////////
// CHECK-NEXT:// The below code is composed by:
// CHECK-NEXT://  1) User source code, which may be under any license (see in original source code)
// CHECK-NEXT://  2) OmpSs@FPGA toolchain code which is licensed under LGPLv3 terms and conditions
// CHECK-NEXT:///////////////////
// CHECK-NEXT:// Top IP Function: foo_moved
// CHECK-NEXT:// Accel. type hash: 6774161735
// CHECK-NEXT:// Num. instances: 1
// CHECK-NEXT:// Wrapper version: 14
// CHECK-NEXT:///////////////////

// CHECK:#include <hls_stream.h>
// CHECK-NEXT:#include <ap_int.h>
// CHECK-NEXT:#include <ap_axi_sdata.h>
// CHECK-NEXT:#include "{{.*}}Inputs/header.fpga.h"
// CHECK-NEXT:static ap_uint<64> __mcxx_taskId;

// CHECK:template<class T>
// CHECK-NEXT:union __mcxx_cast {
// CHECK-NEXT:  unsigned long long int raw;
// CHECK-NEXT:  T typed;
// CHECK-NEXT:};

// CHECK:struct mcxx_inaxis {
// CHECK-NEXT:  ap_uint<64> data;
// CHECK-NEXT:};
// CHECK-NEXT:typedef ap_axiu<64, 1, 1, 2> mcxx_outaxis;

// CHECK:struct __fpga_copyinfo_t {
// CHECK-NEXT:  unsigned long long int copy_address;
// CHECK-NEXT:  unsigned char arg_idx;
// CHECK-NEXT:  unsigned char flags;
// CHECK-NEXT:  unsigned int size;
// CHECK-NEXT:};
// CHECK-NEXT:void mcxx_task_create(const ap_uint<64> type, const ap_uint<8> instanceNum, const ap_uint<8> numArgs, const unsigned long long int args[], const ap_uint<8> numDeps, const unsigned long long int deps[], const ap_uint<8> numCopies, const __fpga_copyinfo_t copies[], hls::stream<mcxx_outaxis>& mcxx_outPort);
// CHECK-NEXT:void mcxx_taskwait(hls::stream<ap_uint<8> >& mcxx_spawnInPort, hls::stream<mcxx_outaxis>& mcxx_outPort);

// CHECK:template <typename T>
// CHECK-NEXT:struct __mcxx_ptr_t {
// CHECK-NEXT:  unsigned long long int val;
// CHECK-NEXT:  __mcxx_ptr_t(unsigned long long int val) : val(val) {}
// CHECK-NEXT:  __mcxx_ptr_t() {}
// CHECK-NEXT:  inline operator __mcxx_ptr_t<const T>() const {
// CHECK-NEXT:    return __mcxx_ptr_t<const T>(val);
// CHECK-NEXT:  }
// CHECK-NEXT:  template <typename V> inline __mcxx_ptr_t<T> operator+(V const val) const {
// CHECK-NEXT:    return __mcxx_ptr_t<T>(this->val + val*sizeof(T));
// CHECK-NEXT:  }
// CHECK-NEXT:  template <typename V> inline __mcxx_ptr_t<T> operator-(V const val) const {
// CHECK-NEXT:    return __mcxx_ptr_t<T>(this->val - val*sizeof(T));
// CHECK-NEXT:  }
// CHECK-NEXT:  template <typename V> inline operator V() const {
// CHECK-NEXT:    return (V)val;
// CHECK-NEXT:  }
// CHECK-NEXT:};
// CHECK-NEXT:template<class T>
// CHECK-NEXT:void nanos6_fpga_memcpy_wideport_in(T * dst, const unsigned long long int addr, const unsigned int num_elems, ap_uint<0>* mcxx_memport) {
// CHECK-NEXT:#pragma HLS inline
// CHECK-NEXT:  for (int i = 0; i < (num_elems-1)/(sizeof(ap_uint<0>)/sizeof(T))+1; ++i) {
// CHECK-NEXT:  #pragma HLS pipeline II=1
// CHECK-NEXT:    ap_uint<0> tmpBuffer;
// CHECK-NEXT:    tmpBuffer = *(mcxx_memport + addr/sizeof(ap_uint<0>) + i);
// CHECK-NEXT:    for (int j = 0; j < (sizeof(ap_uint<0>)/sizeof(T)); ++j) {
// CHECK-NEXT:      __mcxx_cast<T> cast_tmp;
// CHECK-NEXT:      cast_tmp.raw = tmpBuffer((j+1)*sizeof(T)*8-1, j*sizeof(T)*8);
// CHECK-NEXT:      dst[i*(sizeof(ap_uint<0>)/sizeof(T))+j] = cast_tmp.typed;
// CHECK-NEXT:    }
// CHECK-NEXT:  }
// CHECK-NEXT:}
// CHECK-NEXT:template<class T>
// CHECK-NEXT:void nanos6_fpga_memcpy_wideport_out(T * src, const unsigned long long int addr, const unsigned int num_elems, ap_uint<0>* mcxx_memport) {
// CHECK-NEXT:#pragma HLS inline
// CHECK-NEXT:  for (int i = 0; i < (num_elems-1)/(sizeof(ap_uint<0>)/sizeof(T))+1; ++i) {
// CHECK-NEXT:  #pragma HLS pipeline II=1
// CHECK-NEXT:    ap_uint<0> tmpBuffer;
// CHECK-NEXT:    for (int j = 0; j < (sizeof(ap_uint<0>)/sizeof(T)); ++j) {
// CHECK-NEXT:      __mcxx_cast<T> cast_tmp;
// CHECK-NEXT:      cast_tmp.typed = src[i*(sizeof(ap_uint<0>)/sizeof(T))+j];
// CHECK-NEXT:      tmpBuffer((j+1)*sizeof(T)*8-1, j*sizeof(T)*8) = cast_tmp.raw;
// CHECK-NEXT:    }
// CHECK-NEXT:    *(mcxx_memport + addr/sizeof(ap_uint<0>) + i) = tmpBuffer;
// CHECK-NEXT:  }
// CHECK-NEXT:}

// CHECK:typedef enum {
// CHECK-NEXT:  OMPIF_INT = 0,
// CHECK-NEXT:  OMPIF_DOUBLE = 1,
// CHECK-NEXT:  OMPIF_FLOAT = 2
// CHECK-NEXT:} OMPIF_Datatype;

// CHECK:typedef enum {
// CHECK-NEXT:OMPIF_COMM_WORLD
// CHECK-NEXT:} OMPIF_Comm;
// CHECK-NEXT:void OMPIF_Send(const void *data, int count, OMPIF_Datatype datatype, int destination, unsigned char tag, OMPIF_Comm communicator, const ap_uint<8> numDeps, const unsigned long long int deps[], hls::stream<mcxx_outaxis>& mcxx_outPort);
// CHECK-NEXT:void OMPIF_Recv(void *data, int count, OMPIF_Datatype datatype, int source, unsigned char tag, OMPIF_Comm communicator, const ap_uint<8> numDeps, const unsigned long long int deps[], hls::stream<mcxx_outaxis>& mcxx_outPort);
// CHECK-NEXT:void OMPIF_Allgather(void* data, int count, OMPIF_Datatype datatype, unsigned char tag, OMPIF_Comm communicator, unsignedchar ompif_rank, hls::stream<ap_uint<8> >& mcxx_spawnInPort, hls::stream<mcxx_outaxis>& mcxx_outPort);
// CHECK-NEXT:void depend_moved(__mcxx_ptr_t<int > ptr, unsigned char __ompif_rank, unsigned char __ompif_size, hls::stream<mcxx_outaxis> &mcxx_outPort, ap_uint<0> *mcxx_memport);
// CHECK-NEXT:void depend_moved(__mcxx_ptr_t<int > ptr, unsigned char __ompif_rank, unsigned char __ompif_size, hls::stream<mcxx_outaxis> &mcxx_outPort, ap_uint<0> *mcxx_memport) {
// CHECK-NEXT:    int exprExample = (__ompif_rank + -1U) * __ompif_rank;
// CHECK-NEXT:    OMPIF_Send(ptr, exprExample, 0U, 0U, mcxx_outPort);
// CHECK-NEXT:    nanos6_fpga_memcpy_wideport_in(ptr, mcxx_memport);
// CHECK-NEXT:}
// CHECK-NEXT:void foo_moved(__mcxx_ptr_t<int > ptr, unsigned char __ompif_rank, unsigned char __ompif_size, hls::stream<mcxx_outaxis> &mcxx_outPort, ap_uint<0> *mcxx_memport) {
// CHECK-NEXT:    depend_moved(ptr, __ompif_rank, __ompif_size, mcxx_outPort, mcxx_memport);
// CHECK-NEXT:}
// CHECK-NEXT:void mcxx_write_out_port(const ap_uint<64> data, const ap_uint<3> dest, const ap_uint<1> last, hls::stream<mcxx_outaxis>& mcxx_outPort) {
// CHECK-NEXT:  #pragma HLS inline
// CHECK-NEXT:  mcxx_outaxis axis_word;
// CHECK-NEXT:  axis_word.data = data;
// CHECK-NEXT:  axis_word.dest = dest;
// CHECK-NEXT:  axis_word.last = last;
// CHECK-NEXT:  mcxx_outPort.write(axis_word);
// CHECK-NEXT:}
// CHECK-NEXT:void foo_wrapper(hls::stream<ap_uint<64> >& mcxx_inPort, hls::stream<mcxx_outaxis>& mcxx_outPort, hls::stream<ap_uint<8> >& mcxx_spawnInPort, unsigned char ompif_rank, unsigned char ompif_size) {
// CHECK-NEXT:#pragma HLS interface ap_ctrl_none port=return
// CHECK-NEXT:#pragma HLS interface axis port=mcxx_inPort
// CHECK-NEXT:#pragma HLS interface axis port=mcxx_outPort
// CHECK-NEXT:#pragma HLS interface axis port=mcxx_spawnInPort
// CHECK-NEXT:#pragma HLS interface ap_stable port=ompif_rank
// CHECK-NEXT:#pragma HLS interface ap_stable port=ompif_size
// CHECK-NEXT:  mcxx_inPort.read(); //command word
// CHECK-NEXT:  __mcxx_taskId = mcxx_inPort.read();
// CHECK-NEXT:  ap_uint<64> __mcxx_parent_taskId = mcxx_inPort.read();
// CHECK-NEXT:  __mcxx_ptr_t<int> ptr;
// CHECK-NEXT:  {
// CHECK-NEXT:  #pragma HLS protocol fixed
// CHECK-NEXT:    {
// CHECK-NEXT:      ap_uint<8> mcxx_flags_0;
// CHECK-NEXT:      ap_uint<64> mcxx_offset_0;
// CHECK-NEXT:      mcxx_flags_0 = mcxx_inPort.read()(7,0);
// CHECK-NEXT:      ap_wait();
// CHECK-NEXT:      mcxx_offset_0 = mcxx_inPort.read();
// CHECK-NEXT:      ptr.val = mcxx_offset_0;
// CHECK-NEXT:    }
// CHECK-NEXT:    ap_wait();
// CHECK-NEXT:  }
// CHECK-NEXT:  foo_moved(ptr, ompif_rank, ompif_size, mcxx_outPort, mcxx_memport);
// CHECK-NEXT:  {
// CHECK-NEXT:  #pragma HLS protocol fixed
// CHECK-NEXT:    ap_uint<64> header = {{.*}};
// CHECK-NEXT:    ap_wait();
// CHECK-NEXT:    mcxx_write_out_port(header, 0, 0, mcxx_outPort);
// CHECK-NEXT:    ap_wait();
// CHECK-NEXT:    mcxx_write_out_port(__mcxx_taskId, 0, 0, mcxx_outPort);
// CHECK-NEXT:    ap_wait();
// CHECK-NEXT:    mcxx_write_out_port(__mcxx_parent_taskId, 0, 1, mcxx_outPort);
// CHECK-NEXT:    ap_wait();
// CHECK-NEXT:  }
// CHECK-NEXT:}
// CHECK-NEXT:void mcxx_task_create(const ap_uint<64> type, const ap_uint<8> instanceNum, const ap_uint<8> numArgs, const unsigned long long int args[], const ap_uint<8> numDeps, const unsigned long long int deps[], const ap_uint<8> numCopies, const __fpga_copyinfo_t copies[], hls::stream<mcxx_outaxis>& mcxx_outPort) {
// CHECK-NEXT:#pragma HLS inline
// CHECK-NEXT:  const ap_uint<2> destId = 2;
// CHECK-NEXT:  ap_uint<64> tmp;
// CHECK-NEXT:  tmp(15,8)  = numArgs;
// CHECK-NEXT:  tmp(23,16) = numDeps;
// CHECK-NEXT:  tmp(31,24) = numCopies;
// CHECK-NEXT:  mcxx_write_out_port(tmp, destId, 0, mcxx_outPort);
// CHECK-NEXT:  mcxx_write_out_port(__mcxx_taskId, destId, 0, mcxx_outPort);
// CHECK-NEXT:  tmp(47,40) = instanceNum;
// CHECK-NEXT:  tmp(33,0)  = type(33,0);
// CHECK-NEXT:  mcxx_write_out_port(tmp, destId, 0, mcxx_outPort);
// CHECK-NEXT:  for (ap_uint<4> i = 0; i < numDeps(3,0); ++i) {
// CHECK-NEXT:    mcxx_write_out_port(deps[i], destId, numArgs == 0 && numCopies == 0 && i == numDeps-1, mcxx_outPort);
// CHECK-NEXT:  }
// CHECK-NEXT:  for (ap_uint<4> i = 0; i < numCopies(3,0); ++i) {
// CHECK-NEXT:    mcxx_write_out_port(copies[i].copy_address, destId, 0, mcxx_outPort);
// CHECK-NEXT:    tmp(7,0) = copies[i].flags;
// CHECK-NEXT:    tmp(15,8) = copies[i].arg_idx;
// CHECK-NEXT:    tmp(63,32) = copies[i].size;
// CHECK-NEXT:    mcxx_write_out_port(tmp, destId, numArgs == 0 && i == numCopies-1, mcxx_outPort);
// CHECK-NEXT:  }
// CHECK-NEXT:  for (ap_uint<4> i = 0; i < numArgs(3,0); ++i) {
// CHECK-NEXT:    mcxx_write_out_port(args[i], destId, i == numArgs-1, mcxx_outPort);
// CHECK-NEXT:  }
// CHECK-NEXT:}

// CHECK:void mcxx_taskwait(hls::stream<ap_uint<8> >& mcxx_spawnInPort, hls::stream<mcxx_outaxis>& mcxx_outPort) {
// CHECK-NEXT:#pragma HLS inline
// CHECK-NEXT:  ap_wait();
// CHECK-NEXT:  mcxx_write_out_port(__mcxx_taskId, 3, 1, mcxx_outPort);
// CHECK-NEXT:  ap_wait();
// CHECK-NEXT:  mcxx_spawnInPort.read();
// CHECK-NEXT:  ap_wait();
// CHECK-NEXT:}
// CHECK-NEXT:const int ompif_type_sizes[3] = {sizeof(int), sizeof(double), sizeof(float)};
// CHECK-NEXT:void OMPIF_Send(const void *data, int count, OMPIF_Datatype datatype, int destination, unsigned char tag, OMPIF_Comm communicator, const ap_uint<8> numDeps, const unsigned long long int deps[], hls::stream<mcxx_outaxis>& mcxx_outPort) {
// CHECK-NEXT:#pragma HLS inline
// CHECK-NEXT:  ap_uint<64> command;
// CHECK-NEXT:  command(7,0) = 0;
// CHECK-NEXT:  command(15,8) = tag;
// CHECK-NEXT:  command(23,16) = destination+1;
// CHECK-NEXT:  command(63, 32) = (unsigned long long int)data;
// CHECK-NEXT:  unsigned long long int args[2] = {command, (unsigned long long int)count*ompif_type_sizes[(int)datatype]};
// CHECK-NEXT:  mcxx_task_create(4294967299LU, {{.*}}, 2, args, numDeps, deps, 0, 0, mcxx_outPort);
// CHECK-NEXT:}
// CHECK-NEXT:void OMPIF_Recv(void *data, int count, OMPIF_Datatype datatype, int source, unsigned char tag, OMPIF_Comm communicator, const ap_uint<8> numDeps, const unsigned long long int deps[], hls::stream<mcxx_outaxis>& mcxx_outPort) {
// CHECK-NEXT:#pragma HLS inline
// CHECK-NEXT:  ap_uint<64> command;
// CHECK-NEXT:  command(7,0) = 0;
// CHECK-NEXT:  command(15,8) = tag;
// CHECK-NEXT:  command(23,16) = source+1;
// CHECK-NEXT:  command(63, 32) = (unsigned long long int)data;
// CHECK-NEXT:unsigned long long int args[2] = {command, (unsigned long long int)count*ompif_type_sizes[(int)datatype]};
// CHECK-NEXT:  mcxx_task_create(4294967300LU, {{.*}}, 2, args, numDeps, deps, 0, 0, mcxx_outPort);
// CHECK-NEXT:}
// CHECK-NEXT:void OMPIF_Allgather(void *data, int count, OMPIF_Datatype datatype, unsigned char tag, OMPIF_Comm communicator, unsigned char ompif_rank, hls::stream<ap_uint<8> >& mcxx_spawnInPort, hls::stream<mcxx_outaxis>& mcxx_outPort) {
// CHECK-NEXT:#pragma HLS inline
// CHECK-NEXT:  ap_uint<64> command_sender, command_receiver;
// CHECK-NEXT:  const unsigned long long int size = (unsigned long long int)count*ompif_type_sizes[(int)datatype];
// CHECK-NEXT:  command_sender(7,0) = 1; //SENDALL
// CHECK-NEXT:  command_receiver(7, 0) = 1; //RECVALL
// CHECK-NEXT:  command_sender(15, 8) = tag; //TAG
// CHECK-NEXT:  command_receiver(15, 8) = tag;
// CHECK-NEXT:  command_sender(63, 32) = (unsigned long long int)data + (ompif_rank-1)*size;
// CHECK-NEXT:  command_receiver(63, 32) = (unsigned long long int)data;
// CHECK-NEXT:  const unsigned long long int mcxx_args_sender[2] = {command_sender, size};
// CHECK-NEXT:  const unsigned long long int mcxx_args_receiver[2] = {command_receiver, size};
// CHECK-NEXT:  mcxx_task_create(4294967300LU, 255, 2, mcxx_args_receiver, 0, NULL, 0, NULL, mcxx_outPort);
// CHECK-NEXT:  mcxx_task_create(4294967299LU, 255, 2, mcxx_args_sender, 0, NULL, 0, NULL, mcxx_outPort);
// CHECK-NEXT:  mcxx_taskwait(mcxx_spawnInPort, mcxx_outPort);
// CHECK-NEXT:}
// CHECK-NEXT:{
// CHECK-NEXT:    "full_path" : "//foo_hls_automatic_clang.cpp",
// CHECK-NEXT:    "filename" : "foo_hls_automatic_clang.cpp",
// CHECK-NEXT:    "name" : "foo",
// CHECK-NEXT:    "type" : 6774161735,
// CHECK-NEXT:    "num_instances" : 1,
// CHECK-NEXT:    "task_creation" : true,
// CHECK-NEXT:    "instrumentation" : false,
// CHECK-NEXT:    "periodic" : false,
// CHECK-NEXT:    "lock" : false,
// CHECK-NEXT:    "deps" : false,
// CHECK-NEXT:    "ompif" : true
// CHECK-NEXT:},
