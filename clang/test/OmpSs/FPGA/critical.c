// RUN: %clang_cc1 -fompss-2 -fompss-fpga-hls-tasks-dir %{fs-tmp-root} -fompss-fpga -fompss-fpga-wrapper-code -fompss-fpga-dump -ferror-limit 100 %s | FileCheck %s
// expected-no-diagnostics

#include "Inputs/header.h"
#include "Inputs/header.fpga.h"
const int VAL = 0;
void depend();
#pragma oss task device(fpga)
void foo() {
    depend();
}
void depend() {
    #pragma oss critical
    ;
}

// CHECK:foo
// CHECK-NEXT:///////////////////
// CHECK-NEXT:// Automatic IP Generated by OmpSs@FPGA compiler
// CHECK-NEXT:///////////////////
// CHECK-NEXT:// The below code is composed by:
// CHECK-NEXT://  1) User source code, which may be under any license (see in original source code)
// CHECK-NEXT://  2) OmpSs@FPGA toolchain code which is licensed under LGPLv3 terms and conditions
// CHECK-NEXT:///////////////////
// CHECK-NEXT:// Top IP Function: foo_moved
// CHECK-NEXT:// Accel. type hash: 4854598551
// CHECK-NEXT:// Num. instances: 1
// CHECK-NEXT:// Wrapper version: 13
// CHECK-NEXT:///////////////////

// CHECK:#include <hls_stream.h>
// CHECK-NEXT:#include <ap_int.h>
// CHECK-NEXT:#include <ap_axi_sdata.h>
// CHECK-NEXT:#include "{{.*}}Inputs/header.fpga.h"
// CHECK-NEXT:static ap_uint<64> __mcxx_taskId;

// CHECK:template<class T>
// CHECK-NEXT:union __mcxx_cast {
// CHECK-NEXT:  unsigned long long int raw;
// CHECK-NEXT:  T typed;
// CHECK-NEXT:};

// CHECK:struct mcxx_inaxis {
// CHECK-NEXT:  ap_uint<64> data;
// CHECK-NEXT:};
// CHECK-NEXT:typedef ap_axiu<64, 1, 1, 2> mcxx_outaxis;
// CHECK-NEXT:void mcxx_set_lock(hls::stream<ap_uint<64> >& mcxx_inPort, hls::stream<mcxx_outaxis>& mcxx_outPort);
// CHECK-NEXT:void mcxx_unset_lock(hls::stream<mcxx_outaxis>& mcxx_outPort);
// CHECK-NEXT:void depend_moved(hls::stream<ap_uint<64> > &mcxx_inPort, hls::stream<mcxx_outaxis> &mcxx_outPort);
// CHECK-NEXT:void depend_moved(hls::stream<ap_uint<64> > &mcxx_inPort, hls::stream<mcxx_outaxis> &mcxx_outPort) {
// CHECK-NEXT:        {
// CHECK-NEXT:            mcxx_set_lock(mcxx_inPort, mcxx_outPort);
// CHECK-NEXT:            ;
// CHECK-NEXT:            mcxx_unset_lock(mcxx_outPort);
// CHECK-NEXT:        }
// CHECK-NEXT:}
// CHECK-NEXT:void foo_moved(hls::stream<ap_uint<64> > &mcxx_inPort, hls::stream<mcxx_outaxis> &mcxx_outPort) {
// CHECK-NEXT:    depend_moved(mcxx_inPort, mcxx_outPort);
// CHECK-NEXT:}
// CHECK-NEXT:void mcxx_write_out_port(const ap_uint<64> data, const ap_uint<2> dest, const ap_uint<1> last, hls::stream<mcxx_outaxis>& mcxx_outPort) {
// CHECK-NEXT:  #pragma HLS inline
// CHECK-NEXT:  mcxx_outaxis axis_word;
// CHECK-NEXT:  axis_word.data = data;
// CHECK-NEXT:  axis_word.dest = dest;
// CHECK-NEXT:  axis_word.last = last;
// CHECK-NEXT:  mcxx_outPort.write(axis_word);
// CHECK-NEXT:}
// CHECK-NEXT:void foo_wrapper(hls::stream<ap_uint<64> >& mcxx_inPort, hls::stream<mcxx_outaxis>& mcxx_outPort) {
// CHECK-NEXT:#pragma HLS interface ap_ctrl_none port=return
// CHECK-NEXT:#pragma HLS interface axis port=mcxx_inPort
// CHECK-NEXT:#pragma HLS interface axis port=mcxx_outPort
// CHECK-NEXT:  mcxx_inPort.read(); //command word
// CHECK-NEXT:  __mcxx_taskId = mcxx_inPort.read();
// CHECK-NEXT:  ap_uint<64> __mcxx_parent_taskId = mcxx_inPort.read();
// CHECK-NEXT:  {
// CHECK-NEXT:  #pragma HLS protocol fixed
// CHECK-NEXT:  }
// CHECK-NEXT:  foo_moved(mcxx_inPort, mcxx_outPort);
// CHECK-NEXT:  {
// CHECK-NEXT:  #pragma HLS protocol fixed
// CHECK-NEXT:    ap_uint<64> header = {{.*}};
// CHECK-NEXT:    ap_wait();
// CHECK-NEXT:    mcxx_write_out_port(header, 0, 0, mcxx_outPort);
// CHECK-NEXT:    ap_wait();
// CHECK-NEXT:    mcxx_write_out_port(__mcxx_taskId, 0, 0, mcxx_outPort);
// CHECK-NEXT:    ap_wait();
// CHECK-NEXT:    mcxx_write_out_port(__mcxx_parent_taskId, 0, 1, mcxx_outPort);
// CHECK-NEXT:    ap_wait();
// CHECK-NEXT:  }
// CHECK-NEXT:}
// CHECK-NEXT:void mcxx_set_lock(hls::stream<ap_uint<64> >& mcxx_inPort, hls::stream<mcxx_outaxis>& mcxx_outPort) {
// CHECK-NEXT:#pragma HLS inline
// CHECK-NEXT:  ap_uint<64> tmp = {{.*}};
// CHECK-NEXT:  ap_uint<8> ack;
// CHECK-NEXT:  do {
// CHECK-NEXT:    ap_wait();
// CHECK-NEXT:    mcxx_write_out_port(tmp, 1, 1, mcxx_outPort);
// CHECK-NEXT:    ap_wait();
// CHECK-NEXT:    ack = mcxx_inPort.read();
// CHECK-NEXT:    ap_wait();
// CHECK-NEXT:  } while (ack == 0);
// CHECK-NEXT:}
// CHECK:void mcxx_unset_lock(hls::stream<mcxx_outaxis>& mcxx_outPort) {
// CHECK-NEXT:#pragma HLS inline
// CHECK-NEXT:  ap_uint<64> tmp = {{.*}};
// CHECK-NEXT:  mcxx_write_out_port(tmp, 1, 1, mcxx_outPort);
// CHECK-NEXT:}
// CHECK-NEXT:{
// CHECK-NEXT:    "full_path" : "//foo_hls_automatic_clang.cpp",
// CHECK-NEXT:    "filename" : "foo_hls_automatic_clang.cpp",
// CHECK-NEXT:    "name" : "foo",
// CHECK-NEXT:    "type" : 4854598551,
// CHECK-NEXT:    "num_instances" : 1,
// CHECK-NEXT:    "task_creation" : false,
// CHECK-NEXT:    "instrumentation" : false,
// CHECK-NEXT:    "periodic" : false,
// CHECK-NEXT:    "lock" : true,
// CHECK-NEXT:    "deps" : false,
// CHECK-NEXT:    "ompif" : false
// CHECK-NEXT:},
