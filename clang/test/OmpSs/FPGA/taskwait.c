// RUN: %clang_cc1 -fompss-2 -fompss-fpga-hls-tasks-dir %{fs-tmp-root} -fompss-fpga -fompss-fpga-wrapper-code -fompss-fpga-dump -ferror-limit 100 %s | FileCheck %s
// expected-no-diagnostics

#include "Inputs/header.h"
#include "Inputs/header.fpga.h"
const int VAL = 0;
void depend();
#pragma oss task device(fpga)
void foo(int *ptr) {
    depend();
}
void depend() {
    #pragma oss taskwait
}

// CHECK:foo
// CHECK-NEXT:///////////////////
// CHECK-NEXT:// Automatic IP Generated by OmpSs@FPGA compiler
// CHECK-NEXT:///////////////////
// CHECK-NEXT:// The below code is composed by:
// CHECK-NEXT://  1) User source code, which may be under any license (see in original source code)
// CHECK-NEXT://  2) OmpSs@FPGA toolchain code which is licensed under LGPLv3 terms and conditions
// CHECK-NEXT:///////////////////
// CHECK-NEXT:// Top IP Function: foo_moved
// CHECK-NEXT:// Accel. type hash: 4797224880
// CHECK-NEXT:// Num. instances: 1
// CHECK-NEXT:// Wrapper version: 13
// CHECK-NEXT:///////////////////

// CHECK:#include <hls_stream.h>
// CHECK-NEXT:#include <ap_int.h>
// CHECK-NEXT:#include <ap_axi_sdata.h>
// CHECK-NEXT:#include "{{.*}}Inputs/header.fpga.h"
// CHECK-NEXT:static ap_uint<64> __mcxx_taskId;

// CHECK:template<class T>
// CHECK-NEXT:union __mcxx_cast {
// CHECK-NEXT:  unsigned long long int raw;
// CHECK-NEXT:  T typed;
// CHECK-NEXT:};

// CHECK:struct mcxx_inaxis {
// CHECK-NEXT:  ap_uint<64> data;
// CHECK-NEXT:};
// CHECK-NEXT:typedef ap_axiu<64, 1, 1, 2> mcxx_outaxis;

// CHECK:struct __fpga_copyinfo_t {
// CHECK-NEXT:  unsigned long long int copy_address;
// CHECK-NEXT:  unsigned char arg_idx;
// CHECK-NEXT:  unsigned char flags;
// CHECK-NEXT:  unsigned int size;
// CHECK-NEXT:};
// CHECK-NEXT:void mcxx_task_create(const ap_uint<64> type, const ap_uint<8> instanceNum, const ap_uint<8> numArgs, const unsigned long long int args[], const ap_uint<8> numDeps, const unsigned long long int deps[], const ap_uint<8> numCopies, const __fpga_copyinfo_t copies[], hls::stream<mcxx_outaxis>& mcxx_outPort);
// CHECK-NEXT:void mcxx_taskwait(hls::stream<ap_uint<8> >& mcxx_spawnInPort, hls::stream<mcxx_outaxis>& mcxx_outPort);

// CHECK:template <typename T>
// CHECK-NEXT:struct __mcxx_ptr_t {
// CHECK-NEXT:  unsigned long long int val;
// CHECK-NEXT:  __mcxx_ptr_t(unsigned long long int val) : val(val) {}
// CHECK-NEXT:  __mcxx_ptr_t() {}
// CHECK-NEXT:  inline operator __mcxx_ptr_t<const T>() const {
// CHECK-NEXT:    return __mcxx_ptr_t<const T>(val);
// CHECK-NEXT:  }
// CHECK-NEXT:  template <typename V> inline __mcxx_ptr_t<T> operator+(V const val) const {
// CHECK-NEXT:    return __mcxx_ptr_t<T>(this->val + val*sizeof(T));
// CHECK-NEXT:  }
// CHECK-NEXT:  template <typename V> inline __mcxx_ptr_t<T> operator-(V const val) const {
// CHECK-NEXT:    return __mcxx_ptr_t<T>(this->val - val*sizeof(T));
// CHECK-NEXT:  }
// CHECK-NEXT:  template <typename V> inline operator V() const {
// CHECK-NEXT:    return (V)val;
// CHECK-NEXT:  }
// CHECK-NEXT:};
// CHECK-NEXT:void depend_moved(hls::stream<ap_uint<8> > &mcxx_spawnInPort, hls::stream<mcxx_outaxis> &mcxx_outPort);
// CHECK-NEXT:void depend_moved(hls::stream<ap_uint<8> > &mcxx_spawnInPort, hls::stream<mcxx_outaxis> &mcxx_outPort) {
// CHECK-NEXT:        mcxx_taskwait(mcxx_spawnInPort, mcxx_outPort);
// CHECK-NEXT:}
// CHECK-NEXT:void foo_moved(__mcxx_ptr_t<int > ptr, hls::stream<ap_uint<8> > &mcxx_spawnInPort, hls::stream<mcxx_outaxis> &mcxx_outPort) {
// CHECK-NEXT:    depend_moved(mcxx_spawnInPort, mcxx_outPort);
// CHECK-NEXT:}
// CHECK-NEXT:void mcxx_write_out_port(const ap_uint<64> data, const ap_uint<2> dest, const ap_uint<1> last, hls::stream<mcxx_outaxis>& mcxx_outPort) {
// CHECK-NEXT:  #pragma HLS inline
// CHECK-NEXT:  mcxx_outaxis axis_word;
// CHECK-NEXT:  axis_word.data = data;
// CHECK-NEXT:  axis_word.dest = dest;
// CHECK-NEXT:  axis_word.last = last;
// CHECK-NEXT:  mcxx_outPort.write(axis_word);
// CHECK-NEXT:}
// CHECK-NEXT:void foo_wrapper(hls::stream<ap_uint<64> >& mcxx_inPort, hls::stream<mcxx_outaxis>& mcxx_outPort, hls::stream<ap_uint<8> >& mcxx_spawnInPort) {
// CHECK-NEXT:#pragma HLS interface ap_ctrl_none port=return
// CHECK-NEXT:#pragma HLS interface axis port=mcxx_inPort
// CHECK-NEXT:#pragma HLS interface axis port=mcxx_outPort
// CHECK-NEXT:#pragma HLS interface axis port=mcxx_spawnInPort
// CHECK-NEXT:  mcxx_inPort.read(); //command word
// CHECK-NEXT:  __mcxx_taskId = mcxx_inPort.read();
// CHECK-NEXT:  ap_uint<64> __mcxx_parent_taskId = mcxx_inPort.read();
// CHECK-NEXT:  __mcxx_ptr_t<int> ptr;
// CHECK-NEXT:  {
// CHECK-NEXT:  #pragma HLS protocol fixed
// CHECK-NEXT:    {
// CHECK-NEXT:      ap_uint<8> mcxx_flags_0;
// CHECK-NEXT:      ap_uint<64> mcxx_offset_0;
// CHECK-NEXT:      mcxx_flags_0 = mcxx_inPort.read()(7,0);
// CHECK-NEXT:      ap_wait();
// CHECK-NEXT:      mcxx_offset_0 = mcxx_inPort.read();
// CHECK-NEXT:      ptr.val = mcxx_offset_0;
// CHECK-NEXT:    }
// CHECK-NEXT:    ap_wait();
// CHECK-NEXT:  }
// CHECK-NEXT:  foo_moved(ptr, mcxx_spawnInPort, mcxx_outPort);
// CHECK-NEXT:  {
// CHECK-NEXT:  #pragma HLS protocol fixed
// CHECK-NEXT:    ap_uint<64> header = {{.*}};
// CHECK-NEXT:    ap_wait();
// CHECK-NEXT:    mcxx_write_out_port(header, 0, 0, mcxx_outPort);
// CHECK-NEXT:    ap_wait();
// CHECK-NEXT:    mcxx_write_out_port(__mcxx_taskId, 0, 0, mcxx_outPort);
// CHECK-NEXT:    ap_wait();
// CHECK-NEXT:    mcxx_write_out_port(__mcxx_parent_taskId, 0, 1, mcxx_outPort);
// CHECK-NEXT:    ap_wait();
// CHECK-NEXT:  }
// CHECK-NEXT:}
// CHECK-NEXT:void mcxx_task_create(const ap_uint<64> type, const ap_uint<8> instanceNum, const ap_uint<8> numArgs, const unsigned long long int args[], const ap_uint<8> numDeps, const unsigned long long int deps[], const ap_uint<8> numCopies, const __fpga_copyinfo_t copies[], hls::stream<mcxx_outaxis>& mcxx_outPort) {
// CHECK-NEXT:#pragma HLS inline
// CHECK-NEXT:  const ap_uint<2> destId = 2;
// CHECK-NEXT:  ap_uint<64> tmp;
// CHECK-NEXT:  tmp(15,8)  = numArgs;
// CHECK-NEXT:  tmp(23,16) = numDeps;
// CHECK-NEXT:  tmp(31,24) = numCopies;
// CHECK-NEXT:  mcxx_write_out_port(tmp, destId, 0, mcxx_outPort);
// CHECK-NEXT:  mcxx_write_out_port(__mcxx_taskId, destId, 0, mcxx_outPort);
// CHECK-NEXT:  tmp(47,40) = instanceNum;
// CHECK-NEXT:  tmp(33,0)  = type(33,0);
// CHECK-NEXT:  mcxx_write_out_port(tmp, destId, 0, mcxx_outPort);
// CHECK-NEXT:  for (ap_uint<4> i = 0; i < numDeps(3,0); ++i) {
// CHECK-NEXT:    mcxx_write_out_port(deps[i], destId, numArgs == 0 && numCopies == 0 && i == numDeps-1, mcxx_outPort);
// CHECK-NEXT:  }
// CHECK-NEXT:  for (ap_uint<4> i = 0; i < numCopies(3,0); ++i) {
// CHECK-NEXT:    mcxx_write_out_port(copies[i].copy_address, destId, 0, mcxx_outPort);
// CHECK-NEXT:    tmp(7,0) = copies[i].flags;
// CHECK-NEXT:    tmp(15,8) = copies[i].arg_idx;
// CHECK-NEXT:    tmp(63,32) = copies[i].size;
// CHECK-NEXT:    mcxx_write_out_port(tmp, destId, numArgs == 0 && i == numCopies-1, mcxx_outPort);
// CHECK-NEXT:  }
// CHECK-NEXT:  for (ap_uint<4> i = 0; i < numArgs(3,0); ++i) {
// CHECK-NEXT:    mcxx_write_out_port(args[i], destId, i == numArgs-1, mcxx_outPort);
// CHECK-NEXT:  }
// CHECK-NEXT:}

// CHECK:void mcxx_taskwait(hls::stream<ap_uint<8> >& mcxx_spawnInPort, hls::stream<mcxx_outaxis>& mcxx_outPort) {
// CHECK-NEXT:#pragma HLS inline
// CHECK-NEXT:  ap_wait();
// CHECK-NEXT:  mcxx_write_out_port(__mcxx_taskId, 3, 1, mcxx_outPort);
// CHECK-NEXT:  ap_wait();
// CHECK-NEXT:  mcxx_spawnInPort.read();
// CHECK-NEXT:  ap_wait();
// CHECK-NEXT:}
// CHECK-NEXT:{
// CHECK-NEXT:    "full_path" : "//foo_hls_automatic_clang.cpp",
// CHECK-NEXT:    "filename" : "foo_hls_automatic_clang.cpp",
// CHECK-NEXT:    "name" : "foo",
// CHECK-NEXT:    "type" : 4797224880,
// CHECK-NEXT:    "num_instances" : 1,
// CHECK-NEXT:    "task_creation" : true,
// CHECK-NEXT:    "instrumentation" : false,
// CHECK-NEXT:    "periodic" : false,
// CHECK-NEXT:    "lock" : false,
// CHECK-NEXT:    "deps" : false,
// CHECK-NEXT:    "ompif" : false
// CHECK-NEXT:},
